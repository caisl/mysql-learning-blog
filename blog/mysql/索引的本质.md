# 索引（一）索引的本质
## 先看一个sql
```sql
SELECT
	count(*)
FROM
	op_log
WHERE
	method = "updateActivity"
AND operator_id ="shinan"
AND create_time > 1533819466000
AND create_time < 1543819466000
AND type=1;
```
查询效率很慢：<br><br>
**1、如何建立索引？**<br>
**2、索引的顺序如何？**

## What is index

>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。简单说：索引是一种数据结构。

## Why use index
**没有索引的情况下全盘扫描<br>**

### 磁盘IO和预读 ###
>索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。

1.将磁盘想象成一张黑胶唱片<br><br>
2.盘片上有很多磁道，数据就存在磁道上。磁盘可以是单片，也可以多片组成盘组。每个盘片分2个面。盘片装在一根主轴上，绕主轴旋转。当磁道在磁头下通过时，磁头对磁盘进行数据读写。<br><br>
3.各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面。因此，柱面的个数也就是盘面上的磁道数。<br>
![磁盘](http://img.blog.csdn.net/20160202205105560''磁盘'')




#### 磁盘读写原理 ####
磁盘读写某一指定数据分3个步骤<br>
1 磁头定位到磁道。<br><br>
2 选好磁道之后，等待扇区旋转到磁头。<br><br>
3 磁头定位完成，开始读或写操作<br><br>
根据上面的3个步骤，可以知道读写某一指定数据的时间消耗同样有3部分时间组成

寻址时间：完成上述步骤(i)所需要的时间。这部分时间代价最高，最大可达到0.1s左右。

旋转时间：完成上述步骤(2)所需要的时间。由于盘片绕主轴旋转速度很快，一般为7200转/分(电脑硬盘的性能指标之一, 家用的普通硬盘的转速一般有5400rpm(笔记本)、7200rpm几种)。因此一般旋转一圈大约0.0083s（以7200rpm为例，转一圈的时间是1/240，大约为0.004s）。

传输时间：往磁盘传送或从磁盘传送的时间

执行一次IO的时间可以执行几十万条指令

#### 局部性原理和磁盘预读 ####
当一个数据被用到时，其附近的数据也通常会马上被使用。 <br>
程序运行期间所需要的数据通常比较集中。 <br>
由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。<br>


## 索引的数据结构 ##
- 索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数
- B+树(一个高度可控的多路搜索树)

### B+树 ###

![B+树](http://img.blog.csdn.net/20160202205105560''B+树'')


- 非叶子节点只存储键值信息<br>
- 所有叶子节点之间都有一个链指针<br>
- 数据记录都存放在叶子节点中

1. B+Tree的高度一般都在2~4层
2. 查找一个值，IO次数取决于B+数的高度
3. 磁盘块的大小就是页的大小，索引字段越小，内节点存储数据越多

## 建索引的几大原则 ##
- 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询
(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

- =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。
- 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。

- 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。

- 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

```sql
SELECT
	count(*)
FROM
	op_log
WHERE
	method = "updateActivity"
AND operator_id ="shinan"
AND create_time > 1533819466000
AND create_time < 1543819466000
AND type=1;
```
> 建立method,operator_id,type,create_time联合索引

假设还有以下查询：
```sql
select * from op_log where method = "updateActivity" and type = 12;
```
**如何建立索引？**






